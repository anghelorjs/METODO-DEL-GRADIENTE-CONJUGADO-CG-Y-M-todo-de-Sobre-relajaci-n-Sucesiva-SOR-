<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1" />
        <title>M√©todo del Gradiente Conjugado ‚Äî Demo Neon</title>
        <style>
            :root {
                --bg: #05060a;
                --panel: #0c0f1a;
                --text: #e7f5ff;
                --muted: #a7b3c4;
                --neon1: #00e5ff;
                --neon2: #7cff00;
                --neon3: #ff00f0;
                --accent: #37f499;
                --danger: #ff5577;
            }
            * {
                box-sizing: border-box;
            }
            html,
            body {
                height: 100%;
            }
            body {
                margin: 0;
                font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
                color: var(--text);
                background: radial-gradient(1000px 600px at 10% 10%, rgba(0, 229, 255, 0.08), transparent 50%), radial-gradient(800px 500px at 90% 10%, rgba(255, 0, 240, 0.08), transparent 50%),
                    radial-gradient(1200px 700px at 50% 100%, rgba(124, 255, 0, 0.08), transparent 50%), var(--bg);
                overflow-x: hidden;
            }

            /* Glow helpers */
            .glow {
                text-shadow: 0 0 12px rgba(55, 244, 153, 0.6), 0 0 40px rgba(0, 229, 255, 0.25);
            }
            .neon-border {
                border: 1px solid rgba(255, 255, 255, 0.12);
                box-shadow: inset 0 0 18px rgba(255, 255, 255, 0.04), 0 0 24px rgba(0, 229, 255, 0.12), 0 0 64px rgba(255, 0, 240, 0.08);
                border-radius: 16px;
                background: linear-gradient(180deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.01));
                backdrop-filter: blur(6px);
            }

            header {
                padding: 48px 20px 24px;
                text-align: center;
                position: relative;
            }
            header h1 {
                font-size: clamp(28px, 5vw, 48px);
                line-height: 1.05;
                margin: 0 0 10px;
                background: linear-gradient(90deg, var(--neon1), var(--neon3), var(--neon2));
                -webkit-background-clip: text;
                background-clip: text;
                color: transparent;
                filter: drop-shadow(0 0 15px rgba(0, 229, 255, 0.35));
                animation: hue 12s linear infinite;
            }
            header p {
                color: var(--muted);
                margin: 0 auto;
                max-width: 900px;
            }

            @keyframes hue {
                from {
                    filter: hue-rotate(0deg) drop-shadow(0 0 15px rgba(0, 229, 255, 0.35));
                }
                to {
                    filter: hue-rotate(360deg) drop-shadow(0 0 15px rgba(0, 229, 255, 0.35));
                }
            }

            .grid {
                display: grid;
                gap: 18px;
                padding: 20px;
                max-width: 1200px;
                margin: 0 auto 80px;
                grid-template-columns: 1.1fr 0.9fr;
            }
            @media (max-width: 980px) {
                .grid {
                    grid-template-columns: 1fr;
                }
            }

            .card {
                padding: 18px;
            }
            .card h2 {
                margin: 6px 0 12px;
                font-size: 20px;
                letter-spacing: 0.2px;
            }
            .card p,
            .card li {
                color: var(--muted);
            }
            .card ul {
                padding-left: 18px;
            }

            .controls {
                display: grid;
                grid-template-columns: repeat(2, minmax(0, 1fr));
                gap: 10px;
                margin-top: 8px;
            }
            .controls label {
                display: grid;
                gap: 6px;
                font-size: 12px;
                color: var(--muted);
            }
            .controls input[type="number"],
            .controls input[type="range"],
            .controls input[type="text"] {
                background: #0a0d16;
                border: 1px solid rgba(255, 255, 255, 0.12);
                color: var(--text);
                padding: 10px 12px;
                border-radius: 12px;
                outline: none;
                transition: box-shadow 0.2s ease, border-color 0.2s ease;
            }
            .controls input:focus {
                border-color: var(--neon1);
                box-shadow: 0 0 0 6px rgba(0, 229, 255, 0.12);
            }

            .buttons {
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
                margin-top: 10px;
            }
            .btn {
                cursor: pointer;
                border: none;
                color: var(--text);
                padding: 10px 14px;
                border-radius: 12px;
                font-weight: 600;
                letter-spacing: 0.2px;
                background: radial-gradient(120% 120% at 20% 20%, rgba(0, 229, 255, 0.2), rgba(255, 0, 240, 0.1)), #0e1220;
                outline: 1px solid rgba(255, 255, 255, 0.12);
                transition: transform 0.06s ease, box-shadow 0.2s ease, outline-color 0.2s ease;
                box-shadow: 0 0 20px rgba(0, 229, 255, 0.18), 0 2px 12px rgba(0, 0, 0, 0.4);
            }
            .btn:hover {
                outline-color: var(--accent);
                box-shadow: 0 0 30px rgba(55, 244, 153, 0.35);
            }
            .btn:active {
                transform: translateY(1px) scale(0.98);
            }
            .btn.danger:hover {
                outline-color: var(--danger);
                box-shadow: 0 0 30px rgba(255, 85, 119, 0.35);
            }

            .viz {
                display: grid;
                grid-template-columns: 1fr;
                gap: 12px;
                align-content: start;
            }
            .canvas-wrap {
                position: relative;
                aspect-ratio: 1 / 1;
            }
            canvas {
                width: 100%;
                height: 100%;
                display: block;
                image-rendering: pixelated;
                border-radius: 12px;
            }

            .badge {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                padding: 6px 10px;
                border-radius: 999px;
                font-size: 12px;
                color: #0b1b12;
                background: linear-gradient(90deg, rgba(55, 244, 153, 0.9), rgba(0, 229, 255, 0.9));
                box-shadow: 0 0 20px rgba(55, 244, 153, 0.45);
            }

            details {
                border-top: 1px dashed rgba(255, 255, 255, 0.12);
                padding-top: 10px;
                margin-top: 10px;
            }
            details summary {
                cursor: pointer;
                color: var(--text);
            }

            footer {
                max-width: 1200px;
                margin: 0 auto 60px;
                color: var(--muted);
                padding: 0 20px;
                text-align: center;
            }
            .kpi {
                display: grid;
                grid-template-columns: repeat(4, minmax(0, 1fr));
                gap: 10px;
                margin-top: 10px;
            }
            .kpi div {
                padding: 10px;
                border-radius: 12px;
                background: #0a0f18;
                border: 1px dashed rgba(0, 229, 255, 0.25);
                text-align: center;
            }
            @media (max-width: 760px) {
                .kpi {
                    grid-template-columns: repeat(2, minmax(0, 1fr));
                }
            }

            .ticker {
                position: fixed;
                bottom: 14px;
                left: 50%;
                transform: translateX(-50%);
                display: inline-flex;
                gap: 10px;
                align-items: center;
                padding: 8px 12px;
                border-radius: 999px;
                background: rgba(14, 18, 32, 0.75);
                backdrop-filter: blur(6px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                box-shadow: 0 0 20px rgba(0, 229, 255, 0.18);
                font-size: 12px;
                color: var(--muted);
            }
        </style>
    </head>
    <body>
        <header>
            <div class="badge">‚ö° Demo interactiva</div>
            <h1 class="glow">M√©todo del <span style="white-space: nowrap">Gradiente Conjugado</span> (CG)</h1>
            <p>
                Resolvemos un problema real de <strong>difusi√≥n de calor</strong> en una placa delgada. Al discretizar la ecuaci√≥n de Laplace, obtenemos un sistema lineal <code>A x = b</code> grande y
                <em>sim√©trico definido positivo</em> (SPD). El m√©todo CG lo resuelve eficientemente sin formar expl√≠citamente la matriz, usando √∫nicamente productos <code>A¬∑v</code>.
            </p>
        </header>

        <main class="grid">
            <!-- Panel izquierdo: explicaci√≥n + controles -->
            <section class="card neon-border">
                <h2>üìå Problema del mundo real: transferencia de calor</h2>
                <p>
                    Imagina una <strong>placa met√°lica cuadrada</strong> aislada excepto en sus bordes: el borde izquierdo se mantiene a <strong>100&nbsp;¬∞C</strong> y los dem√°s bordes a
                    <strong>0&nbsp;¬∞C</strong>. En estado estacionario, la temperatura interior <em>u(x,y)</em> satisface la ecuaci√≥n de Laplace <code>‚àá¬≤u = 0</code> con condiciones de Dirichlet en el
                    borde. Al discretizar con diferencias finitas (malla regular), obtenemos el sistema SPD <code>A x = b</code> sobre las temperaturas de los nodos interiores.
                </p>
                <ul>
                    <li><strong>Desconocidas:</strong> temperaturas en nodos interiores (tama√±o <code>m√óm</code>).</li>
                    <li><strong>A:</strong> operador Laplaciano (plantilla 5 puntos), SPD.</li>
                    <li><strong>b:</strong> contribuci√≥n de las fronteras conocidas.</li>
                </ul>

                <div class="controls">
                    <label>
                        Resoluci√≥n interior <small>(m)</small>
                        <input
                            id="mInput"
                            type="number"
                            min="8"
                            max="100"
                            step="1"
                            value="40" />
                    </label>
                    <label>
                        Tolerancia (‚Äñr‚Äñ/‚Äñb‚Äñ)
                        <input
                            id="tolInput"
                            type="text"
                            value="1e-6" />
                    </label>
                    <label>
                        Iteraciones m√°x.
                        <input
                            id="maxItInput"
                            type="number"
                            min="10"
                            max="5000"
                            step="10"
                            value="1000" />
                    </label>
                    <label>
                        Temperatura borde izq. (¬∞C)
                        <input
                            id="leftBC"
                            type="number"
                            min="0"
                            max="500"
                            step="5"
                            value="100" />
                    </label>
                </div>
                <div class="buttons">
                    <button
                        class="btn"
                        id="runBtn">
                        ‚ñ∂ Ejecutar CG (animado)
                    </button>
                    <button
                        class="btn"
                        id="stepBtn">
                        ‚û§ Paso simple
                    </button>
                    <button
                        class="btn danger"
                        id="resetBtn">
                        ‚ü≤ Reiniciar
                    </button>
                </div>

                <details>
                    <summary>¬øC√≥mo funciona CG? (resumen)</summary>
                    <p>
                        Para un sistema SPD <code>A x = b</code>, CG genera direcciones <em>conjugadas</em> <code>p‚ÇÄ, p‚ÇÅ, ‚Ä¶</code> tales que <code>p·µ¢·µÄ A p‚±º = 0</code> si <code>i ‚â† j</code>. Con ellas,
                        minimiza la energ√≠a cuadr√°tica <code>œï(x) = ¬Ω x·µÄ A x ‚àí b·µÄ x</code>. En exactitud aritm√©tica, converge en ‚â§ <code>n</code> pasos; en pr√°ctica, depende del
                        <em>n√∫mero de condici√≥n</em> de <code>A</code>. Solo usa productos <code>A¬∑v</code> y productos escalares.
                    </p>
                    <pre style="white-space: pre-wrap; background: #070a12; padding: 10px; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.1)">
Algoritmo CG (boceto)
Entradas: A¬∑v (operador), b, x‚ÇÄ, tol
r‚ÇÄ = b ‚àí A x‚ÇÄ
p‚ÇÄ = r‚ÇÄ
Para k = 0,1,... hasta converger:
  Œ±‚Çñ = (r‚Çñ·µÄ r‚Çñ) / (p‚Çñ·µÄ A p‚Çñ)
  x‚Çñ‚Çä‚ÇÅ = x‚Çñ + Œ±‚Çñ p‚Çñ
  r‚Çñ‚Çä‚ÇÅ = r‚Çñ ‚àí Œ±‚Çñ A p‚Çñ
  Si ‚Äñr‚Çñ‚Çä‚ÇÅ‚Äñ/‚Äñb‚Äñ < tol, parar
  Œ≤‚Çñ = (r‚Çñ‚Çä‚ÇÅ·µÄ r‚Çñ‚Çä‚ÇÅ) / (r‚Çñ·µÄ r‚Çñ)
  p‚Çñ‚Çä‚ÇÅ = r‚Çñ‚Çä‚ÇÅ + Œ≤‚Çñ p‚Çñ
        </pre
                    >
                </details>
            </section>

            <!-- Panel derecho: visualizaciones -->
            <section class="viz">
                <div class="card neon-border">
                    <h2>üå°Ô∏è Temperatura en la placa (heatmap)</h2>
                    <div class="canvas-wrap"><canvas id="heat"></canvas></div>
                    <div class="kpi">
                        <div>
                            <strong>Iteraci√≥n</strong>
                            <div id="iterKpi">‚Äî</div>
                        </div>
                        <div>
                            <strong>‚Äñr‚Äñ/‚Äñb‚Äñ</strong>
                            <div id="resKpi">‚Äî</div>
                        </div>
                        <div>
                            <strong>Dimensi√≥n</strong>
                            <div id="dimKpi">‚Äî</div>
                        </div>
                        <div>
                            <strong>Tiempo</strong>
                            <div id="timeKpi">‚Äî</div>
                        </div>
                    </div>
                </div>
                <div class="card neon-border">
                    <h2>üìâ Norma del residuo (escala log)</h2>
                    <div
                        class="canvas-wrap"
                        style="aspect-ratio: 3/2">
                        <canvas id="chart"></canvas>
                    </div>
                </div>
            </section>
        </main>

        <!-- ===================== SOR SECTION ===================== -->
        <main
            class="grid"
            id="sor-section">
            <!-- Panel izquierdo: explicaci√≥n + controles SOR -->
            <section class="card neon-border">
                <h2>üß© M√©todo de Sobre-Relajaci√≥n Sucesiva (SOR)</h2>
                <p>
                    El <strong>SOR</strong> acelera a Gauss‚ÄìSeidel introduciendo un factor de relajaci√≥n <code>œâ</code> (omega). Para el mismo problema de <strong>difusi√≥n de calor</strong> en placa,
                    actualiza cada nodo interior con el esquema de 5 puntos y luego aplica <em>sobre-relajaci√≥n</em>:
                </p>
                <pre style="white-space: pre-wrap; background: #070a12; padding: 10px; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.1)">
Gauss‚ÄìSeidel (Laplace):
 u·µ¢‚±º ‚Üê ¬º (u·µ¢‚Çä‚ÇÅ‚±º + u·µ¢‚Çã‚ÇÅ‚±º + u·µ¢‚±º‚Çä‚ÇÅ + u·µ¢‚±º‚Çã‚ÇÅ)
SOR con œâ ‚àà (0,2):
 u·µ¢‚±º ‚Üê (1‚àíœâ) u·µ¢‚±º + œâ ¬∑ ¬º (u·µ¢‚Çä‚ÇÅ‚±º + u·µ¢‚Çã‚ÇÅ‚±º + u·µ¢‚±º‚Çä‚ÇÅ + u·µ¢‚±º‚Çã‚ÇÅ)
      </pre
                >
                <p>
                    Con <code>œâ‚âà1</code> se parece a Gauss‚ÄìSeidel; con un <code>œâ</code> bien elegido (t√≠picamente 1.5‚Äì1.95 para Laplace en 2D), <strong>converge mucho m√°s r√°pido</strong>. A
                    diferencia del CG, SOR <em>s√≠</em> usa la malla expl√≠cita y actualiza en el sitio (m√©todo iterativo local).
                </p>

                <div class="controls">
                    <label>
                        Resoluci√≥n interior <small>(m)</small>
                        <input
                            id="mInputSOR"
                            type="number"
                            min="8"
                            max="160"
                            step="1"
                            value="40" />
                    </label>
                    <label>
                        Tolerancia (‚Äñr‚Äñ/‚Äñb‚Äñ)
                        <input
                            id="tolSOR"
                            type="text"
                            value="1e-6" />
                    </label>
                    <label>
                        Iteraciones m√°x.
                        <input
                            id="maxItSOR"
                            type="number"
                            min="10"
                            max="20000"
                            step="10"
                            value="5000" />
                    </label>
                    <label>
                        œâ (relajaci√≥n)
                        <input
                            id="omegaSOR"
                            type="number"
                            min="0.1"
                            max="1.99"
                            step="0.01"
                            value="1.8" />
                    </label>
                    <label>
                        Temp. borde izq. (¬∞C)
                        <input
                            id="leftBCSOR"
                            type="number"
                            min="0"
                            max="500"
                            step="5"
                            value="100" />
                    </label>
                    <label>
                        Pasos por cuadro
                        <input
                            id="stepsPerFrameSOR"
                            type="number"
                            min="1"
                            max="50"
                            step="1"
                            value="5" />
                    </label>
                </div>
                <div class="buttons">
                    <button
                        class="btn"
                        id="runBtnSOR">
                        ‚ñ∂ Ejecutar SOR (animado)
                    </button>
                    <button
                        class="btn"
                        id="stepBtnSOR">
                        ‚û§ Barrido simple
                    </button>
                    <button
                        class="btn danger"
                        id="resetBtnSOR">
                        ‚ü≤ Reiniciar
                    </button>
                </div>

                <details>
                    <summary>¬øCu√°ndo usar SOR?</summary>
                    <ul>
                        <li>Cuando <code>A</code> es dispersa y la malla es natural (FDM/FEM) y quieres un m√©todo local f√°cil de implementar.</li>
                        <li>Cuando precondicionar CG es complejo y un buen <code>œâ</code> da convergencia aceptable.</li>
                        <li>Para resolver de forma incremental (p. ej., cambios locales o condiciones tiempo-real aproximadas).</li>
                    </ul>
                </details>
            </section>

            <!-- Panel derecho: visualizaciones SOR -->
            <section class="viz">
                <div class="card neon-border">
                    <h2>üå°Ô∏è Temperatura (SOR) en la placa</h2>
                    <div class="canvas-wrap"><canvas id="heatSOR"></canvas></div>
                    <div class="kpi">
                        <div>
                            <strong>Iteraci√≥n</strong>
                            <div id="iterKpiSOR">‚Äî</div>
                        </div>
                        <div>
                            <strong>‚Äñr‚Äñ/‚Äñb‚Äñ</strong>
                            <div id="resKpiSOR">‚Äî</div>
                        </div>
                        <div>
                            <strong>Dimensi√≥n</strong>
                            <div id="dimKpiSOR">‚Äî</div>
                        </div>
                        <div>
                            <strong>Tiempo</strong>
                            <div id="timeKpiSOR">‚Äî</div>
                        </div>
                    </div>
                </div>
                <div class="card neon-border">
                    <h2>üìâ Residuo (SOR) ‚Äî escala log</h2>
                    <div
                        class="canvas-wrap"
                        style="aspect-ratio: 3/2">
                        <canvas id="chartSOR"></canvas>
                    </div>
                </div>
            </section>
        </main>

        <footer>
            <p>
                Consejo: en problemas de ingenier√≠a (FEM/CFD), <strong>precondicionar</strong> (p. ej., Jacobi/ILU) mejora notablemente la convergencia del CG al reducir el n√∫mero de condici√≥n de
                <code>A</code>. Aqu√≠ usamos CG <em>sin precondicionador</em> para claridad.
            </p>
        </footer>

        <div class="ticker">Hecho con ‚ô• y <span style="color: var(--accent); font-weight: 700">ne√≥n</span>. Cambia la resoluci√≥n y vuelve a correr.</div>

        <script>
            // =============== Utilidades num√©ricas b√°sicas ===============
            function zeros(n) {
                return new Float64Array(n);
            }
            function copy(a) {
                return new Float64Array(a);
            }
            function dot(a, b) {
                let s = 0,
                    n = a.length;
                for (let i = 0; i < n; i++) s += a[i] * b[i];
                return s;
            }
            function axpy(a, x, y) {
                // y <- a*x + y
                for (let i = 0; i < x.length; i++) y[i] += a * x[i];
            }
            function scal(a, x) {
                for (let i = 0; i < x.length; i++) x[i] *= a;
            }

            // =============== Modelo de placa: Laplaciano 5 puntos ===============
            // Mallado: nodos totales n x n, con m = n-2 nodos interiores desconocidos.
            // Dirichlet: u=TL en x=0 (izq), u=0 en resto de los bordes.

            const heatCanvas = document.getElementById("heat");
            const chartCanvas = document.getElementById("chart");
            const iterKpi = document.getElementById("iterKpi");
            const resKpi = document.getElementById("resKpi");
            const dimKpi = document.getElementById("dimKpi");
            const timeKpi = document.getElementById("timeKpi");

            const mInput = document.getElementById("mInput");
            const tolInput = document.getElementById("tolInput");
            const maxItInput = document.getElementById("maxItInput");
            const leftBCInput = document.getElementById("leftBC");
            const runBtn = document.getElementById("runBtn");
            const stepBtn = document.getElementById("stepBtn");
            const resetBtn = document.getElementById("resetBtn");

            const m = Math.max(8, Math.min(200, parseInt(mInput.value || 40)));
            const n = m + 2; // nodos totales por dimensi√≥n
            const TL = parseFloat(leftBCInput.value || 100);

            let state = {};

            function setupProblem() {
                const m = Math.max(8, Math.min(200, parseInt(mInput.value || 40)));
                const n = m + 2; // nodos totales por dimensi√≥n
                const TL = parseFloat(leftBCInput.value || 100);
                const h = 1 / (n - 1);
                const invh2 = 1 / (h * h);
                const N = m * m; // tama√±o del sistema

                // b: contribuciones de frontera
                const b = zeros(N);
                function id(i, j) {
                    return i * m + j;
                } // i,j = 0..m-1 (interior)
                for (let i = 0; i < m; i++) {
                    for (let j = 0; j < m; j++) {
                        let rhs = 0;
                        // vecino izquierdo toca frontera x=0 ‚Üí u=TL
                        if (j === 0) rhs += TL * invh2;
                        // otros bordes 0¬∞C no aportan
                        b[id(i, j)] = rhs;
                    }
                }

                // Operador A¬∑x para Laplaciano (4* -1 -1 -1 -1)/h^2
                function matvec(x) {
                    const y = zeros(N);
                    for (let i = 0; i < m; i++) {
                        for (let j = 0; j < m; j++) {
                            const k = id(i, j);
                            let s = 4 * x[k];
                            // vecinos interiores
                            s -= i > 0 ? x[id(i - 1, j)] : 0;
                            s -= i < m - 1 ? x[id(i + 1, j)] : 0;
                            s -= j > 0 ? x[id(i, j - 1)] : 0;
                            s -= j < m - 1 ? x[id(i, j + 1)] : 0;
                            y[k] = s * invh2;
                        }
                    }
                    return y;
                }

                const x = zeros(N); // x0 = 0

                // Para visualizar, reconstruimos la grilla n√ón con bordes
                function reconstruct(xv) {
                    const grid = new Float64Array(n * n);
                    // bordes
                    for (let i = 0; i < n; i++) {
                        grid[i * n + 0] = TL; // izquierda
                        grid[i * n + (n - 1)] = 0; // derecha
                    }
                    for (let j = 0; j < n; j++) {
                        grid[0 * n + j] = 0; // arriba
                        grid[(n - 1) * n + j] = 0; // abajo
                    }
                    // interior desde xv
                    for (let i = 0; i < m; i++) {
                        for (let j = 0; j < m; j++) {
                            grid[(i + 1) * n + (j + 1)] = xv[i * m + j];
                        }
                    }
                    return {grid, n};
                }

                // Guardar en estado
                state = {m, n, N, h, invh2, TL, b, matvec, x, iter: 0, r: null, p: null, Ap: null, bnorm: null, hist: [], t0: performance.now(), done: false};
                dimKpi.textContent = `${state.N.toLocaleString("en-US")} ( ${m}√ó${m} )`;
                iterKpi.textContent = "0";
                resKpi.textContent = "‚Äî";
                timeKpi.textContent = "0 ms";

                drawHeat(reconstruct(state.x));
                drawChart([]);
            }
            function reconstruct(xv) {
                const grid = new Float64Array(n * n);
                // bordes
                for (let i = 0; i < n; i++) {
                    grid[i * n + 0] = TL; // izquierda
                    grid[i * n + (n - 1)] = 0; // derecha
                }
                for (let j = 0; j < n; j++) {
                    grid[0 * n + j] = 0; // arriba
                    grid[(n - 1) * n + j] = 0; // abajo
                }
                // interior desde xv
                for (let i = 0; i < m; i++) {
                    for (let j = 0; j < m; j++) {
                        grid[(i + 1) * n + (j + 1)] = xv[i * m + j];
                    }
                }
                return {grid, n};
            }

            // =============== CG paso-a-paso ===============
            function cgInit() {
                const {matvec, b, x} = state;
                const Ax = matvec(x);
                let r = copy(b);
                axpy(-1, Ax, r); // r = b - A x
                let p = copy(r);
                const bnorm = Math.sqrt(Math.max(1e-30, dot(b, b)));
                state.r = r;
                state.p = p;
                state.iter = 0;
                state.bnorm = bnorm;
                state.hist = [];
                state.done = false;
                state.t0 = performance.now();
                updateKPIs();
            }

            function cgStep() {
                const s = state;
                if (s.done) return;
                const {matvec} = s;
                const Ap = matvec(s.p);
                const rr = dot(s.r, s.r);
                const alpha = rr / Math.max(1e-30, dot(s.p, Ap));
                axpy(alpha, s.p, s.x); // x = x + Œ± p
                axpy(-alpha, Ap, s.r); // r = r - Œ± Ap
                const rrNew = dot(s.r, s.r);
                const beta = rrNew / Math.max(1e-30, rr);
                // p = r + Œ≤ p
                for (let i = 0; i < s.p.length; i++) s.p[i] = s.r[i] + beta * s.p[i];

                s.iter++;
                const rel = Math.sqrt(rrNew) / (s.bnorm || 1);
                s.hist.push(rel);
                if (!isFinite(rel) || rel <= parseFloat(tolInput.value || "1e-6") || s.iter >= parseInt(maxItInput.value || 1000)) {
                    s.done = true;
                }
                updateKPIs(rel);
                drawHeat(reconstruct(s.x));
                drawChart(s.hist);
            }

            function updateKPIs(rel) {
                iterKpi.textContent = String(state.iter);
                resKpi.textContent = rel == null ? "‚Äî" : rel < 1e-12 ? rel.toExponential(2) : rel.toFixed(6);
                const ms = Math.max(0, performance.now() - state.t0);
                timeKpi.textContent = `${ms.toFixed(0)} ms`;
            }

            // =============== Visualizaci√≥n: heatmap simple + l√≠nea log10 ===============
            function drawHeat({grid, n}) {
                const ctx = heatCanvas.getContext("2d");
                // Asegura dimensiones de dibujo basadas en el tama√±o CSS del canvas
                const W = Math.max(1, heatCanvas.clientWidth * devicePixelRatio);
                const H = Math.max(1, heatCanvas.clientHeight * devicePixelRatio);
                heatCanvas.width = W;
                heatCanvas.height = H;

                // min/max para escalar colores
                let mn = Infinity,
                    mx = -Infinity;
                for (let i = 0; i < grid.length; i++) {
                    const v = grid[i];
                    if (v < mn) mn = v;
                    if (v > mx) mx = v;
                }
                const img = new ImageData(n, n);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        const v = grid[i * n + j];
                        const t = (v - mn) / (mx - mn + 1e-12);
                        const c1 = [0, 229, 255],
                            c2 = [255, 0, 240],
                            c3 = [124, 255, 0];
                        let r, g, b;
                        if (t < 0.5) {
                            const u = t * 2;
                            r = c1[0] * (1 - u) + c2[0] * u;
                            g = c1[1] * (1 - u) + c2[1] * u;
                            b = c1[2] * (1 - u) + c2[2] * u;
                        } else {
                            const u = (t - 0.5) * 2;
                            r = c2[0] * (1 - u) + c3[0] * u;
                            g = c2[1] * (1 - u) + c3[1] * u;
                            b = c2[2] * (1 - u) + c3[2] * u;
                        }
                        const idx = (i * n + j) * 4;
                        img.data[idx] = r;
                        img.data[idx + 1] = g;
                        img.data[idx + 2] = b;
                        img.data[idx + 3] = 255;
                    }
                }
                // Fallback si OffscreenCanvas no est√° disponible
                let offCanvas;
                if (typeof OffscreenCanvas !== "undefined") {
                    offCanvas = new OffscreenCanvas(n, n);
                } else {
                    offCanvas = document.createElement("canvas");
                    offCanvas.width = n;
                    offCanvas.height = n;
                }
                const octx = offCanvas.getContext("2d");
                octx.putImageData(img, 0, 0);
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(offCanvas, 0, 0, W, H);
            }

            function drawChart(hist) {
                const ctx = chartCanvas.getContext("2d");
                const W = chartCanvas.clientWidth * devicePixelRatio;
                const H = chartCanvas.clientHeight * devicePixelRatio;
                chartCanvas.width = W;
                chartCanvas.height = H;
                ctx.clearRect(0, 0, W, H);
                // Marco
                ctx.strokeStyle = "rgba(0,229,255,.6)";
                ctx.lineWidth = 2;
                ctx.strokeRect(10, 10, W - 20, H - 20);
                if (!hist || hist.length === 0) return;
                // log10 residuo
                const y = hist.map((v) => Math.log10(Math.max(1e-20, v)));
                const xmin = 0,
                    xmax = hist.length - 1;
                let ymin = Infinity,
                    ymax = -Infinity;
                for (const val of y) {
                    if (val < ymin) ymin = val;
                    if (val > ymax) ymax = val;
                }
                if (ymin === ymax) {
                    ymin -= 1;
                    ymax += 1;
                }
                function X(i) {
                    return 10 + (W - 20) * ((i - xmin) / Math.max(1, xmax - xmin));
                }
                function Y(v) {
                    return 10 + (H - 20) * (1 - (v - ymin) / (ymax - ymin));
                }
                ctx.beginPath();
                ctx.moveTo(X(0), Y(y[0]));
                for (let i = 1; i < y.length; i++) ctx.lineTo(X(i), Y(y[i]));
                ctx.strokeStyle = "rgba(255,0,240,.8)";
                ctx.lineWidth = 3;
                ctx.shadowColor = "rgba(255,0,240,.6)";
                ctx.shadowBlur = 10;
                ctx.stroke();
            }

            // =============== Animaci√≥n de CG ===============
            let animId = null;
            function animate() {
                if (state.done) {
                    cancelAnimationFrame(animId);
                    animId = null;
                    return;
                }
                for (let t = 0; t < 3; t++) cgStep(); // 3 pasos por frame para agilidad
                animId = requestAnimationFrame(animate);
            }

            // =============== Eventos ===============
            runBtn.addEventListener("click", () => {
                if (!state.r) cgInit();
                if (animId) cancelAnimationFrame(animId);
                animId = requestAnimationFrame(animate);
            });
            stepBtn.addEventListener("click", () => {
                if (!state.r) cgInit();
                if (animId) cancelAnimationFrame(animId);
                cgStep();
            });
            resetBtn.addEventListener("click", () => {
                if (animId) cancelAnimationFrame(animId);
                setupProblem();
            });

            // Inicializar
            setupProblem();

            /* ===================== SOR IMPLEMENTACI√ìN ===================== */
            const heatCanvasSOR = document.getElementById("heatSOR");
            const chartCanvasSOR = document.getElementById("chartSOR");
            const iterKpiSOR = document.getElementById("iterKpiSOR");
            const resKpiSOR = document.getElementById("resKpiSOR");
            const dimKpiSOR = document.getElementById("dimKpiSOR");
            const timeKpiSOR = document.getElementById("timeKpiSOR");

            const mInputSOR = document.getElementById("mInputSOR");
            const tolSOR = document.getElementById("tolSOR");
            const maxItSOR = document.getElementById("maxItSOR");
            const omegaSOR = document.getElementById("omegaSOR");
            const leftBCSOR = document.getElementById("leftBCSOR");
            const stepsPerFrameSOR = document.getElementById("stepsPerFrameSOR");

            const runBtnSOR = document.getElementById("runBtnSOR");
            const stepBtnSOR = document.getElementById("stepBtnSOR");
            const resetBtnSOR = document.getElementById("resetBtnSOR");

            let sor = {};

            function setupSOR() {
                const m = Math.max(8, Math.min(240, parseInt(mInputSOR.value || 40)));
                const n = m + 2;
                const TL = parseFloat(leftBCSOR.value || 100);
                const h = 1 / (n - 1);
                const invh2 = 1 / (h * h);
                const N = m * m;

                // Estado de temperatura incluyendo bordes (n√ón)
                const U = new Float64Array(n * n);
                // Bordes
                for (let i = 0; i < n; i++) {
                    U[i * n + 0] = TL; // izquierda
                    U[i * n + (n - 1)] = 0; // derecha
                }
                for (let j = 0; j < n; j++) {
                    U[0 * n + j] = 0; // arriba
                    U[(n - 1) * n + j] = 0; // abajo
                }

                // Vector b para residuo (solo interior)
                const b = new Float64Array(N);
                function id(i, j) {
                    return i * m + j;
                }
                function gid(i, j) {
                    return (i + 1) * n + (j + 1);
                } // a grilla con bordes
                for (let i = 0; i < m; i++) {
                    for (let j = 0; j < m; j++) {
                        let rhs = 0;
                        if (j === 0) rhs += TL * invh2;
                        b[id(i, j)] = rhs;
                    }
                }

                function matvecVec(xv) {
                    const y = new Float64Array(N);
                    for (let i = 0; i < m; i++) {
                        for (let j = 0; j < m; j++) {
                            const k = id(i, j);
                            let s = 4 * xv[k];
                            if (i > 0) s -= xv[id(i - 1, j)];
                            if (i < m - 1) s -= xv[id(i + 1, j)];
                            if (j > 0) s -= xv[id(i, j - 1)];
                            if (j < m - 1) s -= xv[id(i, j + 1)];
                            y[k] = s * invh2;
                        }
                    }
                    return y;
                }

                function extractX() {
                    const xv = new Float64Array(N);
                    for (let i = 0; i < m; i++) for (let j = 0; j < m; j++) xv[id(i, j)] = U[gid(i, j)];
                    return xv;
                }

                sor = {m, n, N, h, invh2, TL, U, b, iter: 0, hist: [], done: false, t0: performance.now(), matvecVec, extractX};
                dimKpiSOR.textContent = `${N.toLocaleString("en-US")} ( ${m}√ó${m} )`;
                iterKpiSOR.textContent = "0";
                resKpiSOR.textContent = "‚Äî";
                timeKpiSOR.textContent = "0 ms";
                drawHeatSOR();
                drawChartSOR([]);
            }

            function sorSweep() {
                const œâ = Math.max(0.1, Math.min(1.99, parseFloat(omegaSOR.value || 1.8)));
                const s = sor;
                const {U, n} = s;
                // Un barrido sobre todos los interiores
                for (let i = 1; i < n - 1; i++) {
                    for (let j = 1; j < n - 1; j++) {
                        const idx = i * n + j;
                        const avg = 0.25 * (U[(i + 1) * n + j] + U[(i - 1) * n + j] + U[i * n + (j + 1)] + U[i * n + (j - 1)]);
                        U[idx] = (1 - œâ) * U[idx] + œâ * avg;
                    }
                }
                sor.iter++;
                // Residuo relativo
                const x = s.extractX();
                const Ax = s.matvecVec(x);
                let rr = 0,
                    bb = 0;
                for (let k = 0; k < s.N; k++) {
                    const rk = s.b[k] - Ax[k];
                    rr += rk * rk;
                    bb += s.b[k] * s.b[k];
                }
                const rel = Math.sqrt(rr) / Math.max(1e-30, Math.sqrt(bb));
                sor.hist.push(rel);
                if (rel <= parseFloat(tolSOR.value || "1e-6") || sor.iter >= parseInt(maxItSOR.value || 5000)) sor.done = true;
                iterKpiSOR.textContent = String(sor.iter);
                resKpiSOR.textContent = rel < 1e-12 ? rel.toExponential(2) : rel.toFixed(6);
                const ms = Math.max(0, performance.now() - sor.t0);
                timeKpiSOR.textContent = `${ms.toFixed(0)} ms`;
                drawHeatSOR();
                drawChartSOR(sor.hist);
            }

            function drawHeatSOR() {
                const ctx = heatCanvasSOR.getContext("2d");
                const W = heatCanvasSOR.clientWidth * devicePixelRatio;
                const H = heatCanvasSOR.clientHeight * devicePixelRatio;
                heatCanvasSOR.width = W;
                heatCanvasSOR.height = H;
                const n = sor.n;
                const grid = sor.U;
                // min/max
                let mn = Infinity,
                    mx = -Infinity;
                for (let i = 0; i < grid.length; i++) {
                    const v = grid[i];
                    if (v < mn) mn = v;
                    if (v > mx) mx = v;
                }
                const img = ctx.createImageData(n, n);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        const v = grid[i * n + j];
                        const t = (v - mn) / (mx - mn + 1e-12);
                        const c1 = [0, 229, 255],
                            c2 = [255, 0, 240],
                            c3 = [124, 255, 0];
                        let r, g, b;
                        if (t < 0.5) {
                            const u = t * 2;
                            r = c1[0] * (1 - u) + c2[0] * u;
                            g = c1[1] * (1 - u) + c2[1] * u;
                            b = c1[2] * (1 - u) + c2[2] * u;
                        } else {
                            const u = (t - 0.5) * 2;
                            r = c2[0] * (1 - u) + c3[0] * u;
                            g = c2[1] * (1 - u) + c3[1] * u;
                            b = c2[2] * (1 - u) + c3[2] * u;
                        }
                        const idx = (i * n + j) * 4;
                        img.data[idx + 0] = r;
                        img.data[idx + 1] = g;
                        img.data[idx + 2] = b;
                        img.data[idx + 3] = 255;
                    }
                }
                const off = new OffscreenCanvas(n, n);
                const octx = off.getContext("2d");
                octx.putImageData(img, 0, 0);
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(off, 0, 0, W, H);
            }

            function drawChartSOR(hist) {
                const ctx = chartCanvasSOR.getContext("2d");
                const W = chartCanvasSOR.clientWidth * devicePixelRatio;
                const H = chartCanvasSOR.clientHeight * devicePixelRatio;
                chartCanvasSOR.width = W;
                chartCanvasSOR.height = H;
                ctx.clearRect(0, 0, W, H);
                ctx.strokeStyle = "rgba(0,229,255,.6)";
                ctx.lineWidth = 2;
                ctx.strokeRect(10, 10, W - 20, H - 20);
                if (!hist || hist.length === 0) return;
                const y = hist.map((v) => Math.log10(Math.max(1e-20, v)));
                const xmin = 0,
                    xmax = hist.length - 1;
                let ymin = Infinity,
                    ymax = -Infinity;
                for (const v of y) {
                    if (v < ymin) ymin = v;
                    if (v > ymax) ymax = v;
                }
                if (ymin === ymax) {
                    ymin -= 1;
                    ymax += 1;
                }
                function X(i) {
                    return 10 + (W - 20) * ((i - xmin) / Math.max(1, xmax - xmin));
                }
                function Y(v) {
                    return 10 + (H - 20) * (1 - (v - ymin) / (ymax - ymin));
                }
                ctx.beginPath();
                ctx.moveTo(X(0), Y(y[0]));
                for (let i = 1; i < y.length; i++) ctx.lineTo(X(i), Y(y[i]));
                ctx.strokeStyle = "rgba(124,255,0,.9)";
                ctx.lineWidth = 3;
                ctx.shadowColor = "rgba(124,255,0,.6)";
                ctx.shadowBlur = 10;
                ctx.stroke();
            }

            let animSOR = null;
            function animateSOR() {
                if (sor.done) {
                    cancelAnimationFrame(animSOR);
                    animSOR = null;
                    return;
                }
                const steps = Math.max(1, Math.min(50, parseInt(stepsPerFrameSOR.value || 5)));
                for (let t = 0; t < steps; t++) sorSweep();
                animSOR = requestAnimationFrame(animateSOR);
            }

            runBtnSOR.addEventListener("click", () => {
                if (!sor.U) setupSOR();
                if (animSOR) cancelAnimationFrame(animSOR);
                animSOR = requestAnimationFrame(animateSOR);
            });
            stepBtnSOR.addEventListener("click", () => {
                if (!sor.U) setupSOR();
                if (animSOR) cancelAnimationFrame(animSOR);
                sorSweep();
            });
            resetBtnSOR.addEventListener("click", () => {
                if (animSOR) cancelAnimationFrame(animSOR);
                setupSOR();
            });

            // Inicializar SOR al cargar
            setupSOR();
        </script>
    </body>
</html>
